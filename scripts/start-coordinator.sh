#!/bin/bash

################################################################################
# Hyperion Coordinator Startup Script
#
# Manages folder mapping for code indexing and port configuration
#
# Usage:
#   ./scripts/start-coordinator.sh                    # Interactive wizard mode
#   ./scripts/start-coordinator.sh --folder /path/to/project [--port 5173]
#   ./scripts/start-coordinator.sh --folder /path/to/project1 --folder /path/to/project2
#   ./scripts/start-coordinator.sh --help
################################################################################

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
PUBLIC_PORT=5173
PROJECT_NAME=""
FOLDERS=()
DEV_MODE=false
DOCKER_COMPOSE_FILE="docker-compose.yml"
OVERRIDE_FILE="docker-compose.volumes.yml"

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# .hyper config file in CURRENT working directory (not script dir)
HYPER_CONFIG_FILE="$(pwd)/.hyper"

################################################################################
# Functions
################################################################################

save_config() {
    log_info "Saving configuration to .hyper file..."

    cat > "$HYPER_CONFIG_FILE" << EOF
# Hyperion Coordinator Configuration
# Auto-generated by start-coordinator.sh
# Edit manually or run the wizard again to regenerate

PROJECT_NAME="$PROJECT_NAME"
PUBLIC_PORT=$PUBLIC_PORT
DEV_MODE=$DEV_MODE

# Folders (one per line)
FOLDERS=(
EOF

    for folder in "${FOLDERS[@]}"; do
        echo "  \"$folder\"" >> "$HYPER_CONFIG_FILE"
    done

    echo ")" >> "$HYPER_CONFIG_FILE"

    log_success "Configuration saved to: $HYPER_CONFIG_FILE"
}

load_config() {
    if [[ ! -f "$HYPER_CONFIG_FILE" ]]; then
        return 1
    fi

    log_info "Found .hyper configuration: $HYPER_CONFIG_FILE"

    # Source the config file
    source "$HYPER_CONFIG_FILE"

    log_success "Loaded configuration:"
    log_info "  Project: $PROJECT_NAME"
    log_info "  Port: $PUBLIC_PORT"
    log_info "  Mode: $([ "$DEV_MODE" == "true" ] && echo "Development" || echo "Production")"
    log_info "  Folders: ${#FOLDERS[@]}"

    for folder in "${FOLDERS[@]}"; do
        log_info "    - $folder"
    done

    return 0
}

print_usage() {
    cat << EOF
${BLUE}Hyperion Coordinator Startup Script${NC}

${GREEN}Usage:${NC}
    $0                      # Interactive wizard mode (recommended for first-time setup)
    $0 --folder <path> [OPTIONS]

${GREEN}Options:${NC}
    --folder <path>     Folder to map for code indexing (can be specified multiple times)
    --port <port>       Public port for UI (default: 5173)
    --name <name>       Docker Compose project name (default: hyperion-coordinator)
    --dev               Use development mode with hot-reload
    --reconfigure       Ignore existing .hyper config and run wizard
    --stop              Stop the services
    --clean             Stop services and remove volumes
    --help              Show this help message

${GREEN}Examples:${NC}
    # Interactive wizard (easiest way to get started)
    $0

    # Start with single folder
    $0 --folder /Users/max/projects/hyperion

    # Start with multiple folders
    $0 --folder /Users/max/projects/app1 --folder /Users/max/projects/app2

    # Use custom port
    $0 --folder /Users/max/projects/hyperion --port 8080

    # Multiple instances for different projects
    $0 --folder /Users/max/projects/app1 --port 5173 --name hyperion-app1
    $0 --folder /Users/max/projects/app2 --port 5174 --name hyperion-app2

    # Development mode with hot-reload
    $0 --folder /Users/max/projects/hyperion --dev

    # Stop services (auto-detects project from .hyper)
    $0 --stop

    # Stop specific instance by name
    $0 --stop --name hyperion-app1

    # Stop and clean (removes volumes too)
    $0 --clean --name hyperion-app2

${GREEN}What it does:${NC}
    1. Validates folder paths exist
    2. Generates docker-compose override with volume mounts
    3. Creates path mappings for file watcher
    4. Starts coordinator services with single public port
    5. Shows access URLs and next steps

${YELLOW}Notes:${NC}
    - Folders are mounted read-only for security
    - All mapped folders are accessible under /workspace in container
    - File watcher automatically monitors mounted folders
    - Use different --name for multiple instances
    - Each instance needs a unique port
    - Use Ctrl+C to stop services or run: $0 --stop --name <project-name>

EOF
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

validate_folder() {
    local folder="$1"
    if [[ ! -d "$folder" ]]; then
        log_error "Folder does not exist: $folder"
        exit 1
    fi

    # Convert to absolute path
    folder=$(cd "$folder" && pwd)
    echo "$folder"
}

generate_override_file() {
    # Use project-specific override file if project name is set
    local override_file="$OVERRIDE_FILE"
    if [[ -n "$PROJECT_NAME" ]]; then
        override_file="docker-compose.${PROJECT_NAME}.yml"
    fi
    local override_path="$PROJECT_ROOT/$override_file"

    log_info "Generating docker-compose override file..."

    # Build path mappings for environment variable
    local path_mappings=""
    local mount_index=0

    for folder in "${FOLDERS[@]}"; do
        local container_path="/workspace/mount${mount_index}"
        if [[ -z "$path_mappings" ]]; then
            path_mappings="${folder}:${container_path}"
        else
            path_mappings="${path_mappings},${folder}:${container_path}"
        fi
        mount_index=$((mount_index + 1))
    done

    # Generate docker-compose override for unified coordinator
    cat > "$override_path" << EOF
# Auto-generated by start-coordinator.sh
# DO NOT EDIT MANUALLY - This file is regenerated on each start
# Unified Architecture: Single coordinator service (REST API + UI serving)

version: '3.8'

services:
  # Unified Coordinator - Only service in unified architecture
  hyperion-coordinator:
    environment:
      # Path mappings for file watcher (container path:host path)
      - CODE_INDEX_PATH_MAPPINGS=${path_mappings}
    volumes:
EOF

    # Add volume mounts
    mount_index=0
    for folder in "${FOLDERS[@]}"; do
        local container_path="/workspace/mount${mount_index}"
        echo "      - ${folder}:${container_path}:ro" >> "$override_path"
        mount_index=$((mount_index + 1))
    done

    # Configure coordinator public port (REST API + UI)
    cat >> "$override_path" << EOF
    ports:
      - "${PUBLIC_PORT}:7095"  # REST API + UI serving
EOF

    log_success "Override file created: $override_path"

    # Store override file path for later use
    OVERRIDE_FILE="$override_file"
}

stop_services() {
    local project_name_arg=""
    if [[ -n "$PROJECT_NAME" ]]; then
        project_name_arg="-p $PROJECT_NAME"
        log_info "Stopping Hyperion Coordinator services (project: $PROJECT_NAME)..."
    else
        log_info "Stopping Hyperion Coordinator services..."
    fi

    cd "$PROJECT_ROOT"

    # Find override file if it exists
    local override_file="$OVERRIDE_FILE"
    if [[ -n "$PROJECT_NAME" ]]; then
        override_file="docker-compose.${PROJECT_NAME}.yml"
    fi

    if [[ "$DEV_MODE" == "true" ]]; then
        docker-compose $project_name_arg \
            --profile local-qdrant \
            -f docker-compose.yml \
            -f docker-compose.dev.yml \
            down
    elif [[ -f "$PROJECT_ROOT/$override_file" ]]; then
        docker-compose $project_name_arg \
            --profile local-qdrant \
            -f docker-compose.yml \
            -f "$override_file" \
            down
    else
        docker-compose $project_name_arg \
            --profile local-qdrant \
            -f docker-compose.yml \
            down
    fi

    log_success "Services stopped"
}

clean_services() {
    local project_name_arg=""
    if [[ -n "$PROJECT_NAME" ]]; then
        project_name_arg="-p $PROJECT_NAME"
        log_info "Stopping services and removing volumes (project: $PROJECT_NAME)..."
    else
        log_info "Stopping services and removing volumes..."
    fi

    cd "$PROJECT_ROOT"

    # Find override file if it exists
    local override_file="$OVERRIDE_FILE"
    if [[ -n "$PROJECT_NAME" ]]; then
        override_file="docker-compose.${PROJECT_NAME}.yml"
    fi

    if [[ "$DEV_MODE" == "true" ]]; then
        docker-compose $project_name_arg \
            --profile local-qdrant \
            -f docker-compose.yml \
            -f docker-compose.dev.yml \
            down -v
    elif [[ -f "$PROJECT_ROOT/$override_file" ]]; then
        docker-compose $project_name_arg \
            --profile local-qdrant \
            -f docker-compose.yml \
            -f "$override_file" \
            down -v
    else
        docker-compose $project_name_arg \
            --profile local-qdrant \
            -f docker-compose.yml \
            down -v
    fi

    # Remove override file
    if [[ -f "$PROJECT_ROOT/$override_file" ]]; then
        rm "$PROJECT_ROOT/$override_file"
        log_info "Removed override file"
    fi

    log_success "Services stopped and volumes removed"
}

start_services() {
    local project_name_arg=""
    if [[ -n "$PROJECT_NAME" ]]; then
        project_name_arg="-p $PROJECT_NAME"
        log_info "Starting Hyperion Coordinator services (project: $PROJECT_NAME)..."
    else
        log_info "Starting Hyperion Coordinator services..."
    fi

    cd "$PROJECT_ROOT"

    if [[ "$DEV_MODE" == "true" ]]; then
        log_info "Starting in development mode with hot-reload and local Qdrant..."
        docker-compose $project_name_arg \
            --profile local-qdrant \
            -f docker-compose.yml \
            -f docker-compose.dev.yml \
            -f "$OVERRIDE_FILE" \
            up -d
    else
        log_info "Starting in production mode with local Qdrant..."
        docker-compose $project_name_arg \
            --profile local-qdrant \
            -f docker-compose.yml \
            -f "$OVERRIDE_FILE" \
            up -d
    fi

    log_success "Services started!"
}

show_status() {
    local project_display=""
    if [[ -n "$PROJECT_NAME" ]]; then
        project_display=" (${PROJECT_NAME})"
    fi

    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}  Hyperion Coordinator Running${project_display}${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    if [[ -n "$PROJECT_NAME" ]]; then
        echo -e "${BLUE}ðŸ“¦ Project:${NC}"
        echo -e "   Name:         ${GREEN}${PROJECT_NAME}${NC}"
        echo -e "   Config:       ${GREEN}${OVERRIDE_FILE}${NC}"
        echo ""
    fi
    echo -e "${BLUE}ðŸŒ Access URLs:${NC}"
    echo -e "   UI:            ${GREEN}http://localhost:${PUBLIC_PORT}/ui/${NC}"
    echo -e "   REST API:      ${GREEN}http://localhost:${PUBLIC_PORT}/api/tasks${NC}"
    echo -e "   Health:        ${GREEN}http://localhost:${PUBLIC_PORT}/health${NC}"
    echo ""
    echo -e "${BLUE}ðŸ“ Mounted Folders:${NC}"
    local mount_index=0
    for folder in "${FOLDERS[@]}"; do
        local container_path="/workspace/mount${mount_index}"
        echo -e "   ${YELLOW}${folder}${NC}"
        echo -e "   â†’ ${GREEN}${container_path}${NC}"
        mount_index=$((mount_index + 1))
    done
    echo ""
    echo -e "${BLUE}ðŸ” Code Indexing:${NC}"
    echo -e "   File watcher: ${GREEN}ALWAYS ENABLED${NC}"
    echo -e "   Real-time updates: ${GREEN}YES${NC}"
    echo -e "   Path mappings: ${GREEN}${#FOLDERS[@]} configured${NC}"
    echo ""
    echo -e "${BLUE}ðŸ“‹ Next Steps:${NC}"
    echo -e "   1. Open UI: ${GREEN}http://localhost:${PUBLIC_PORT}/ui/${NC}"
    echo -e "   2. Add folders to index via REST API or UI"
    echo -e "   3. Search code: ${YELLOW}curl -X POST http://localhost:${PUBLIC_PORT}/api/code-index/search -d '{\"query\":\"...\",\"limit\":5}'${NC}"
    echo ""
    echo -e "${BLUE}ðŸ”Œ Claude Code Integration:${NC}"
    if [[ -n "$PROJECT_NAME" ]]; then
        echo -e "   ${YELLOW}claude mcp add hyper-${PROJECT_NAME} --transport http http://localhost:${PUBLIC_PORT}/mcp${NC}"
    else
        echo -e "   ${YELLOW}claude mcp add hyper-coordinator --transport http http://localhost:${PUBLIC_PORT}/mcp${NC}"
    fi
    echo ""
    echo -e "${BLUE}ðŸ“Š View Logs:${NC}"
    if [[ -n "$PROJECT_NAME" ]]; then
        echo -e "   All services:  ${YELLOW}docker-compose -p $PROJECT_NAME -f docker-compose.yml -f $OVERRIDE_FILE logs -f${NC}"
        echo -e "   Coordinator:   ${YELLOW}docker logs -f ${PROJECT_NAME}-hyperion-coordinator-1${NC}"
        echo -e "   MongoDB:       ${YELLOW}docker logs -f ${PROJECT_NAME}-mongodb-1${NC}"
        echo -e "   Qdrant:        ${YELLOW}docker logs -f ${PROJECT_NAME}-qdrant-1${NC}"
    else
        echo -e "   All services:  ${YELLOW}docker-compose -f docker-compose.yml -f $OVERRIDE_FILE logs -f${NC}"
        echo -e "   Coordinator:   ${YELLOW}docker logs -f hyperion-coordinator-1${NC}"
        echo -e "   MongoDB:       ${YELLOW}docker logs -f mongodb-1${NC}"
        echo -e "   Qdrant:        ${YELLOW}docker logs -f qdrant-1${NC}"
    fi
    echo ""
    echo -e "${BLUE}ðŸ›‘ Stop Services:${NC}"
    echo -e "   ${YELLOW}hyper --stop${NC}  (preserves data)"
    echo -e "   ${YELLOW}hyper --clean${NC} (removes volumes & data)"
    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
}

run_interactive_wizard() {
    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}  Hyperion Coordinator Setup Wizard${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""

    # Get current directory as default
    local current_dir=$(pwd)
    local current_folder_name=$(basename "$current_dir")

    # Collect folders
    echo -e "${BLUE}ðŸ“ Folder Configuration${NC}"
    echo -e "   Enter folders to index for code search and file watching."
    echo -e "   ${YELLOW}Tip: You can add multiple folders${NC}"
    echo ""

    local folder_input=""
    local add_more=true
    local is_first_folder=true

    while $add_more; do
        if $is_first_folder; then
            read -p "$(echo -e ${GREEN}Enter folder path${NC} [default: current folder]: )" folder_input
        else
            read -p "$(echo -e ${GREEN}Enter folder path${NC} [or press Enter to finish]: )" folder_input
        fi

        if [[ -z "$folder_input" ]]; then
            if $is_first_folder; then
                # Use current directory as default
                folder_input="$current_dir"
                log_info "Using current folder: $current_dir"
            elif [[ ${#FOLDERS[@]} -eq 0 ]]; then
                log_error "At least one folder is required"
                continue
            else
                add_more=false
                break
            fi
        fi

        if [[ -n "$folder_input" ]]; then
            # Expand ~ to home directory
            folder_input="${folder_input/#\~/$HOME}"

            # Validate folder exists
            if [[ ! -d "$folder_input" ]]; then
                log_error "Folder does not exist: $folder_input"
                continue
            fi

            # Convert to absolute path
            folder_input=$(cd "$folder_input" && pwd)
            FOLDERS+=("$folder_input")
            log_success "Added: $folder_input"

            # Mark that we've processed the first folder
            is_first_folder=false

            echo ""
            read -p "$(echo -e ${BLUE}Add another folder?${NC} [y/N]: )" add_another
            if [[ ! "$add_another" =~ ^[Yy]$ ]]; then
                add_more=false
            fi
        fi
    done

    echo ""
    echo -e "${BLUE}ðŸŒ Port Configuration${NC}"
    echo -e "   The UI will be accessible at http://localhost:<PORT>"
    echo ""

    read -p "$(echo -e ${GREEN}Enter public port${NC} [default: 5173]: )" port_input
    if [[ -z "$port_input" ]]; then
        PUBLIC_PORT=5173
    else
        if [[ "$port_input" =~ ^[0-9]+$ ]] && [[ "$port_input" -ge 1024 ]] && [[ "$port_input" -le 65535 ]]; then
            PUBLIC_PORT="$port_input"
        else
            log_error "Invalid port: $port_input (must be between 1024-65535)"
            log_info "Using default: 5173"
            PUBLIC_PORT=5173
        fi
    fi

    # Check if port is already in use
    if lsof -Pi :$PUBLIC_PORT -sTCP:LISTEN -t >/dev/null 2>&1 ; then
        log_error "Port $PUBLIC_PORT is already in use"
        read -p "$(echo -e ${YELLOW}Enter a different port:${NC} )" port_input
        if [[ "$port_input" =~ ^[0-9]+$ ]] && [[ "$port_input" -ge 1024 ]] && [[ "$port_input" -le 65535 ]]; then
            PUBLIC_PORT="$port_input"
        else
            log_error "Invalid port. Exiting."
            exit 1
        fi
    fi

    log_success "Using port: $PUBLIC_PORT"

    echo ""
    echo -e "${BLUE}ðŸ“¦ Project Configuration${NC}"
    echo -e "   Project name is used for Docker Compose containers and volumes."
    echo -e "   ${YELLOW}Tip: Use unique names if running multiple instances${NC}"
    echo ""

    read -p "$(echo -e ${GREEN}Enter project name${NC} [default: $current_folder_name]: )" name_input
    if [[ -z "$name_input" ]]; then
        PROJECT_NAME="$current_folder_name"
    else
        PROJECT_NAME="$name_input"
    fi
    log_success "Project name: $PROJECT_NAME"

    echo ""
    echo -e "${BLUE}âš™ï¸  Development Mode${NC}"
    echo -e "   Development mode enables hot-reload for code changes."
    echo ""

    read -p "$(echo -e ${GREEN}Enable development mode?${NC} [y/N]: )" dev_input
    if [[ "$dev_input" =~ ^[Yy]$ ]]; then
        DEV_MODE=true
        log_success "Development mode enabled"
    else
        DEV_MODE=false
        log_info "Production mode selected"
    fi

    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}  Configuration Summary${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${BLUE}ðŸ“ Folders (${#FOLDERS[@]}):${NC}"
    for folder in "${FOLDERS[@]}"; do
        echo -e "   ${YELLOW}$folder${NC}"
    done
    echo ""
    echo -e "${BLUE}ðŸŒ Port:${NC}         $PUBLIC_PORT"
    echo -e "${BLUE}ðŸ“¦ Project:${NC}      $PROJECT_NAME"
    echo -e "${BLUE}âš™ï¸  Mode:${NC}         $([ "$DEV_MODE" == "true" ] && echo "Development" || echo "Production")"
    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""

    read -p "$(echo -e ${YELLOW}Start Hyperion Coordinator with this configuration?${NC} [Y/n]: )" confirm
    if [[ "$confirm" =~ ^[Nn]$ ]]; then
        log_info "Setup cancelled by user"
        exit 0
    fi

    echo ""
    log_success "Starting Hyperion Coordinator..."
}

################################################################################
# Main Script
################################################################################

# Save original argument count to detect interactive mode
ORIGINAL_ARG_COUNT=$#

# Parse arguments
STOP_SERVICES=false
CLEAN_SERVICES=false
RECONFIGURE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --folder)
            FOLDERS+=("$(validate_folder "$2")")
            shift 2
            ;;
        --port)
            PUBLIC_PORT="$2"
            shift 2
            ;;
        --name)
            PROJECT_NAME="$2"
            shift 2
            ;;
        --dev)
            DEV_MODE=true
            shift
            ;;
        --reconfigure)
            RECONFIGURE=true
            shift
            ;;
        --stop)
            STOP_SERVICES=true
            shift
            ;;
        --clean)
            CLEAN_SERVICES=true
            shift
            ;;
        --help|-h)
            print_usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            print_usage
            exit 1
            ;;
    esac
done

# Run interactive wizard or load config if no arguments provided
if [[ $ORIGINAL_ARG_COUNT -eq 0 ]] || [[ "$RECONFIGURE" == "true" ]]; then
    # Check for existing .hyper config
    if [[ "$RECONFIGURE" == "true" ]] || ! load_config; then
        run_interactive_wizard
    else
        echo ""
        read -p "$(echo -e ${YELLOW}Use this configuration?${NC} [Y/n]: )" use_config
        if [[ "$use_config" =~ ^[Nn]$ ]]; then
            log_info "Running configuration wizard..."
            echo ""
            run_interactive_wizard
        else
            log_success "Using saved configuration"
        fi
    fi
fi

# Handle stop/clean commands - load config if no project name specified
if [[ "$CLEAN_SERVICES" == "true" ]] || [[ "$STOP_SERVICES" == "true" ]]; then
    if [[ -z "$PROJECT_NAME" ]]; then
        # Try to load project name from .hyper config
        if load_config > /dev/null 2>&1; then
            log_info "Auto-detected project from .hyper: $PROJECT_NAME"
        else
            log_warning "No .hyper config found and no --name specified"
            log_info "Stopping default services without project name"
        fi
    fi
fi

if [[ "$CLEAN_SERVICES" == "true" ]]; then
    clean_services
    exit 0
fi

if [[ "$STOP_SERVICES" == "true" ]]; then
    stop_services
    exit 0
fi

# Validate folders provided (only in command-line mode)
if [[ ${#FOLDERS[@]} -eq 0 ]] && [[ $ORIGINAL_ARG_COUNT -gt 0 ]]; then
    log_error "No folders specified. Use --folder to specify at least one folder."
    echo ""
    print_usage
    exit 1
fi

# Validate port
if ! [[ "$PUBLIC_PORT" =~ ^[0-9]+$ ]] || [[ "$PUBLIC_PORT" -lt 1024 ]] || [[ "$PUBLIC_PORT" -gt 65535 ]]; then
    log_error "Invalid port: $PUBLIC_PORT (must be between 1024-65535)"
    exit 1
fi

# Check if port is already in use
if lsof -Pi :$PUBLIC_PORT -sTCP:LISTEN -t >/dev/null 2>&1 ; then
    log_error "Port $PUBLIC_PORT is already in use"
    log_info "Either stop the process using this port or choose a different port with --port"
    exit 1
fi

# Set default project name if not provided (command-line mode only)
if [[ -z "$PROJECT_NAME" ]]; then
    PROJECT_NAME="hyperion-coordinator"
    if [[ $ORIGINAL_ARG_COUNT -gt 0 ]]; then
        log_info "Using default project name: $PROJECT_NAME"
    fi
fi

# Show configuration (only in command-line mode, wizard already showed this)
if [[ $ORIGINAL_ARG_COUNT -gt 0 ]]; then
    log_info "Configuration:"
    log_info "  Project Name: $PROJECT_NAME"
    log_info "  Public Port: $PUBLIC_PORT"
    log_info "  Mode: $([ "$DEV_MODE" == "true" ] && echo "Development" || echo "Production")"
    log_info "  Folders: ${#FOLDERS[@]}"
fi

# Generate docker-compose override
generate_override_file

# Start services
start_services

# Wait for services to be healthy
log_info "Waiting for services to be healthy..."
sleep 5

# Check health
if curl -sf "http://localhost:${PUBLIC_PORT}/health" > /dev/null 2>&1; then
    log_success "UI is healthy"
else
    log_warning "UI health check failed - services may still be starting"
fi

# Save configuration for next time
save_config

# Show status
show_status
